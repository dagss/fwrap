python module pyf_support
    interface
        subroutine testone(m_hidden, m, n, arr)
            integer intent(hide), depend(m) :: m_hidden=m+1
            integer intent(in), check((m>=1) && (m_hidden <= 10)) :: m
            integer intent(in) :: n = 2
            real*8 intent(out),dimension(m_hidden,n),depend(m_hidden,n) :: arr
            check(n>=2) :: arr
        end subroutine


        subroutine reorders(zp, xp, yp)
            callstatement { (*f2py_func)(&xp, yp, &zp ); }
            ! The in,out of f2py corresponds to the "inout" of fwrap.
            ! The "inout" of f2py is not supported
            integer intent(in,out) :: xp, zp
            integer intent(in,out) :: yp(4)
        end subroutine

        function fort_sum_simple(n, arr) result(x)
            callstatement (*f2py_func)(&x, &n, arr)
            real*8 intent(in), dimension(n) :: arr
            integer optional, intent(in) :: n = len(arr)
            real*8 :: x
        end function

        function fort_sum(n, arr, offx) result(x)
            callstatement (*f2py_func)(&x, &n, arr + offx)
            real*8 intent(in), dimension(n) :: arr
            real*8 :: x
            integer intent(in) :: offx = 0
            check(offx>=0 && offx<len(arr)) :: offx
            integer optional, intent(in) :: n = (len(arr) - offx)
        end function

        subroutine intent_copy_arange(x, n)
          real*8, intent(in,out,copy), dimension(n) :: x
          integer :: n
        end subroutine

        subroutine intent_overwrite_arange(x, n)
          real*8, intent(in,out,overwrite), dimension(n) :: x
          integer :: n
        end subroutine

        subroutine intent_inout_arange(x, n) ! and fortranname
          fortranname intent_overwrite_arange
          real*8, intent(inout), dimension(n) :: x
          integer, intent(in) :: n
        end subroutine intent_inout_arange

        function sum_and_fill_optional_arrays(x, y, z, m, n)
          ! m, n will end up first Python-side
          double precision dimension(m,n), intent(in,out), optional :: x = 0
          complex*16 dimension(m,n), intent(in,out,copy), optional :: y = (0,0.)
          integer dimension(m,n), intent(in,out,copy), optional :: z ! optional without def.val.
          integer :: m, n
          complex*16 :: sum_and_fill_optional_arrays
        end function

        function aux_arg(a, b, c)
          integer :: a
          integer :: aux_arg
          integer intent(in) :: c = a + 1
          integer intent(hide) :: b = c + 1
          callstatement (*f2py_func)(&aux_arg, &b, (b>10)?"A":"B")
        end function
        
        subroutine a_function(y, x)
          ! Function masquerading as subroutine in pyf
          integer, intent(out) :: x
          integer, intent(in,out) :: y
          callstatement (*f2py_func)(&x, &y)
        end subroutine

        subroutine sdefault(z)
          real, intent(in,out) :: z = 1.
        end subroutine

        subroutine cdefault(z)
          complex, intent(in,out) :: z = (1., 0.)
        end subroutine


        subroutine temparray(n, x, y)
          integer, dimension(n) :: x, y
          intent(in,out) :: x
          intent(hide) :: y
          integer :: n
        end subroutine temparray

        subroutine alignment(n, a, b, c)
          integer :: n
          integer*4, dimension(n), intent(in,out,overwrite) :: a, b, c
          intent(aligned8) :: b
          intent(aligned16) :: c
        end subroutine alignment

        subroutine scalars_initialized_to_zero(x, y, z, one, ok)
          integer, intent(out) :: x
          integer, intent(hide) :: one = 1
          real*8, intent(out),  :: y
          complex*16, intent(out)  :: z
          logical, intent(out) :: ok
        end subroutine

    end interface 
end python module pyf_support

